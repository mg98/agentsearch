#!/usr/bin/env node
require("dotenv").config();
const fs = require("fs").promises;
const path = require("path");
const pLimit = require("p-limit");

if (process.env.SENTRY_DSN) {
  const Raven = require("raven");
  Raven.config(process.env.SENTRY_DSN).install();
}

const converter = require("../src/converter");
const program = require("commander");

async function main(argv) {
  program
    .version("0.0.1")
    .usage("[options] <tex file or directory> <output directory>")
    .option("-o, --output <dir>", "(deprecated) Output directory")
    .option(
      "--no-post-processing",
      "Raw LaTeXML output, without filters or postprocessors (for debugging)"
    )
    .option(
      "--css <path>",
      "URL or path to external CSS to use instead of the default CSS. If passed, the defaut CSS is not copied to the output directory."
    )
    .option(
      "--javascript <path>",
      "URL or path to external JavaScript to use instead of the default JS. If not passed, the default JS is not copied to the output directory."
    )
    .option(
      "--biblio-glutton-url <url>",
      "URL to a biblio-glutton instance to resolve citations into links"
    )
    .option(
      "--grobid-url <url>",
      "URL to a grobid instance to resolve citations into links"
    )
    .parse(argv);

  const src_dir = program.args[0];
  const html_dir = program.args[1] || program.output;

  if (!src_dir || !html_dir) {
    program.outputHelp();
    return 1;
  }

  // Get list of all papers
  const papers = [];
  const authors = await fs.readdir(src_dir);
  for (const author of authors) {
    const authorPath = path.join(src_dir, author);
    const stats = await fs.stat(authorPath);
    if (stats.isDirectory()) {
      const files = await fs.readdir(authorPath);
      for (const file of files) {
        if (file.endsWith('.tar.gz')) {
          const paper = file.slice(0, -7); // Remove .tar.gz
          papers.push({
            input: path.join(src_dir, author, file),
            output: path.join(html_dir, author),
            filename: `${paper}.html`
          });
        }
      }
    }
  }
  const renderPromises = papers.map(paper => {
    return () => {
      const options = {
        input: paper.input,
        output: paper.output,
        filename: paper.filename,
        postProcessing: program.postProcessing,
        externalCSS: program.css,
        externalJavaScript: program.javascript,
        biblioGluttonUrl: program.biblioGluttonUrl
          ? program.biblioGluttonUrl
          : process.env.BIBLIO_GLUTTON_URL,
        grobidUrl: program.grobidUrl ? program.grobidUrl : process.env.GROBID_URL,
      };

      return converter.render(options)
        .then(out => {
          console.log("ðŸ’ƒ  Document successfully rendered to", out);
          return out;
        })
        .catch(err => {
          console.warn(`âš ï¸  Failed to render ${paper.input}:`, err);
          return null;
        });
    };
  });

  const limit = pLimit(require('os').cpus().length);
  const results = await Promise.all(
    renderPromises.map(task => limit(task))
  );
  const successfulRenders = results.filter(result => result !== null);
  console.log(`Rendered ${successfulRenders.length} out of ${papers.length} papers successfully`);

  return 0;
}

main(process.argv)
  .then((exitCode) => process.exit(exitCode))
  .catch((err) => {
    console.error("Engrafo rendering failed:", err);
    process.exit(1);
  });
